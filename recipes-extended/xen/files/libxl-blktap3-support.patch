################################################################################
SHORT DESCRIPTION:
################################################################################
Libxl patch to support blktap3

################################################################################
LONG DESCRIPTION:
################################################################################
Modified libxl so as to be compatible with blktap3 for creation, operation and 
destruction of tapdisk.

################################################################################
CHANGELOG
################################################################################
Initial work from Thanos Makatos
https://github.com/qiaohaiming/blktap3/blob/master/libxl.diff

Contributions by:
Mahantesh Salimath <salimathm@ainfosec.com>

################################################################################
UPSTREAM PLAN
################################################################################
Could be upstreamed

################################################################################
PATCHES
################################################################################
--- a/tools/libxl/libxl_internal.h
+++ b/tools/libxl/libxl_internal.h
@@ -2080,6 +2080,13 @@ _hidden char *libxl__object_to_json(libx
 _hidden void libxl__cpuid_legacy(libxl_ctx *ctx, uint32_t domid, bool retore,
                                  libxl_domain_build_info *info);
 
+_hidden char *libxl__blktap_devpath(libxl__gc *gc,
+		                    const char *disk,
+				    libxl_disk_format format,
+				    char *keydir);
+
+_hidden int libxl__device_destroy_tapdisk(libxl__gc *gc, const char *params);
+
 /* Calls poll() again - useful to check whether a signaled condition
  * is still true.  Cannot fail.  Returns currently-true revents. */
 _hidden short libxl__fd_poll_recheck(libxl__egc *egc, int fd, short events);
--- /dev/null
+++ b/tools/libxl/libxl_blktap3.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2012      Advanced Micro Devices
+ * Author Christoph Egger <Christoph.Egger@amd.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation; version 2.1 only.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ */
+
+#include "libxl_osdeps.h" /* must come before any other headers */
+#include "libxl_internal.h"
+
+#include <tap-ctl.h>
+
+#include <list.h>   /* include for list_head structure */
+
+static int blktap_find(const char *type, const char *path, tap_list_t *tap)
+{
+    struct list_head list; /* Note: structure name updated */
+    tap_list_t *entry, *next_t;
+    int ret = -ENOENT, err;
+
+    /* TAILQ_INIT(&list);--> old function */
+    INIT_LIST_HEAD(&list);
+
+    err = tap_ctl_list(&list);
+    if (err)
+        return err;
+
+    /* TAILQ_EMPTY(&list)--> old function */
+    if (list_empty(&list))
+        return ret;
+
+    tap_list_for_each_entry_safe(entry, next_t, &list) {
+
+        if (type && (!entry->type || strcmp(entry->type, type)))
+            continue;
+
+        if (path && (!entry->path || strcmp(entry->path, path)))
+            continue;
+
+        *tap = *entry;
+        tap->type = tap->path = NULL;
+        ret = 0;
+        break;
+    }
+
+    tap_ctl_list_free(&list);
+
+    return ret;
+}
+
+char *libxl__blktap_devpath(libxl__gc *gc, const char *disk,
+		libxl_disk_format format, char *keydir)
+{
+    const char *type = NULL;
+    char *params, *devname = NULL;
+    tap_list_t tap;
+    int err = 0;
+    int flags = 0;
+
+    type = libxl__device_disk_string_of_format(format);
+
+    err = blktap_find(type, disk, &tap);
+    if (!err) {
+        LOG(DEBUG, "found tapdisk\n");
+        devname = libxl__sprintf(gc, "/dev/xen/blktap-2/tapdev%d", tap.minor);
+        if (devname)
+            return devname;
+    }
+
+    LOG(DEBUG, "tapdisk not found\n");
+
+	/* TODO Should we worry about return codes other than ENOENT? */
+
+    if (!keydir || !strncmp(keydir, "", 1))
+        setenv("TAPDISK3_CRYPTO_KEYDIR", "/config/platform-crypto-keys", 1);
+    else
+        setenv("TAPDISK3_CRYPTO_KEYDIR", keydir, 1);
+
+    params = libxl__sprintf(gc, "%s:%s", type, disk);
+
+    err = tap_ctl_create(params, &devname, flags, -1, 0, 0, NULL, NULL);
+    if (!err) {
+        LOG(DEBUG, "created tapdisk\n");
+        return devname;
+    }
+
+    LOG(ERROR, "error creating tapdisk: %s\n", strerror(err));
+
+    return NULL;
+}
+
+int libxl__device_destroy_tapdisk(libxl__gc *gc, const char *params)
+{
+    char *type, *disk;
+    int err;
+    tap_list_t tap;
+
+    type = libxl__strdup(gc, params);
+    disk = strchr(type, ':');
+    if (!disk) {
+        LOG(ERROR, "Unable to parse params %s", params);
+        return ERROR_INVAL;
+    }
+
+    *disk++ = '\0';
+
+    err = blktap_find(type, disk, &tap);
+    if (err < 0) {
+        /* returns -errno */
+        LOGEV(ERROR, -err, "Unable to find type %s disk %s", type, disk);
+        return ERROR_FAIL;
+    }
+
+    err = tap_ctl_destroy(tap.pid, tap.minor, 0, NULL);
+    if (err < 0) {
+        LOGEV(ERROR, -err, "Failed to destroy tap device id %d minor %d",
+              tap.pid, tap.minor);
+        return ERROR_FAIL;
+    }
+
+    return 0;
+}
+
+/*
+ * Local variables:
+ * mode: C
+ * c-basic-offset: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
--- a/tools/libxl/libxl_device.c
+++ b/tools/libxl/libxl_device.c
@@ -946,7 +946,9 @@ void libxl__initiate_device_generic_remo
     STATE_AO_GC(aodev->ao);
     xs_transaction_t t = 0;
     char *be_path = libxl__device_backend_path(gc, aodev->dev);
+    char *fe_path = libxl__device_frontend_path(gc, aodev->dev);
     char *state_path = GCSPRINTF("%s/state", be_path);
+    char *fe_state_path = GCSPRINTF("%s/state", fe_path);
     char *online_path = GCSPRINTF("%s/online", be_path);
     const char *state;
     libxl_dominfo info;
@@ -1023,6 +1025,11 @@ void libxl__initiate_device_generic_remo
                 LOGD(ERROR, domid, "unable to write to xenstore path %s", state_path);
                 goto out;
             }
+            rc = libxl__xs_write_checked(gc, t, fe_state_path, GCSPRINTF("%d", XenbusStateClosed));
+            if (rc) {
+                LOGD(ERROR, domid, "unable to write to xenstore path %s", fe_state_path);
+                goto out;
+            }
         }
 
         rc = libxl__xs_transaction_commit(gc, &t);
--- a/tools/libxl/libxl_disk.c
+++ b/tools/libxl/libxl_disk.c
@@ -56,7 +56,7 @@ static void disk_eject_xswatch_callback(
             "/local/domain/%d/backend/%" TOSTRING(BACKEND_STRING_SIZE)
            "[a-z]/%*d/%*d",
            &disk->backend_domid, backend_type);
-    if (!strcmp(backend_type, "tap") || !strcmp(backend_type, "vbd")) {
+    if (!strcmp(backend_type, "tap") || !strcmp(backend_type, "vbd") || !strcmp(backend_type, "vbd3")) {
         disk->backend = LIBXL_DISK_BACKEND_TAP;
     } else if (!strcmp(backend_type, "qdisk")) {
         disk->backend = LIBXL_DISK_BACKEND_QDISK;
@@ -188,7 +188,7 @@ static int libxl__device_from_disk(libxl
             device->backend_kind = LIBXL__DEVICE_KIND_VBD;
             break;
         case LIBXL_DISK_BACKEND_TAP:
-            device->backend_kind = LIBXL__DEVICE_KIND_VBD;
+            device->backend_kind = LIBXL__DEVICE_KIND_VBD3;
             break;
         case LIBXL_DISK_BACKEND_QDISK:
             device->backend_kind = LIBXL__DEVICE_KIND_QDISK;
@@ -321,9 +321,28 @@ static void device_disk_add(libxl__egc *
                 break;
 
             case LIBXL_DISK_BACKEND_TAP:
-                LOG(ERROR, "blktap is not supported");
-                rc = ERROR_FAIL;
-                goto out;
+                dev = libxl__blktap_devpath(gc, disk->pdev_path,
+                                            disk->format, disk->crypto_key_dir);
+                if (!dev) {
+                     LOGD(ERROR, domid, "failed to get blktap devpath for %s: %s\n",
+                          disk->pdev_path, strerror(rc));
+                     rc = ERROR_FAIL;
+                     goto out;
+                }
+                LOG(DEBUG,"\nBLKTAP3_DEBUG: dev path = %s \n", dev);
+                if (!disk->script && disk->backend_domid == LIBXL_TOOLSTACK_DOMID) {
+                    int major, minor;
+                    if (!libxl__device_physdisk_major_minor(dev, &major, &minor)) {
+                        LOG(DEBUG, "\nBLKTAP3_DEBUG: major:minor = %x:%x\n",major,minor);
+                        flexarray_append_pair(back, "physical-device",
+                                GCSPRINTF("%x:%x", major, minor));
+                    }
+                }
+                flexarray_append(back, "tapdisk-params");
+                flexarray_append(back, GCSPRINTF("%s:%s",
+                    libxl__device_disk_string_of_format(disk->format),
+                    disk->pdev_path));
+                break;
             case LIBXL_DISK_BACKEND_QDISK:
                 flexarray_append(back, "params");
                 flexarray_append(back, GCSPRINTF("%s:%s",
@@ -521,6 +540,16 @@ static int libxl__disk_from_xenstore(lib
     }
     libxl_string_to_backend(ctx, tmp, &(disk->backend));
 
+    /* NOTE: Below workaround is required while dealing with iso hotswap.
+     * Trying to fix this inside libxl_string_to_backend() will break the
+     * initial disk setup during domain start-up.
+     */
+    tmp = libxl__xs_read(gc, XBT_NULL,
+                         GCSPRINTF("%s/tapdisk-params", libxl_path));
+    if (tmp && strcmp(tmp, "")) {
+    	disk->backend = LIBXL_DISK_BACKEND_TAP;
+    }
+
     disk->vdev = xs_read(ctx->xsh, XBT_NULL,
                          GCSPRINTF("%s/dev", libxl_path), &len);
     if (!disk->vdev) {
--- a/tools/libxl/Makefile
+++ b/tools/libxl/Makefile
@@ -145,6 +145,8 @@ LIBXL_OBJS = flexarray.o libxl.o libxl_c
 LIBXL_OBJS += libxl_genid.o
 LIBXL_OBJS += _libxl_types.o libxl_flask.o _libxl_types_internal.o
 
+LIBXL_OBJS += libxl_blktap3.o
+
 LIBXL_TESTS += timedereg
 LIBXL_TESTS_PROGS = $(LIBXL_TESTS) fdderegrace
 LIBXL_TESTS_INSIDE = $(LIBXL_TESTS) fdevent
--- a/tools/libxl/libxl_types.idl
+++ b/tools/libxl/libxl_types.idl
@@ -517,6 +517,9 @@ libxl_domain_build_info = Struct("domain
     ("cpuid",           libxl_cpuid_policy_list),
     ("blkdev_start",    string),
 
+    # directory containing the crypto keys for the VM's disks
+    ("crypto_key_dir", string),
+
     ("vnuma_nodes", Array(libxl_vnode_info, "num_vnuma_nodes")),
 
     ("max_grant_frames",    uint32, {'init_val': 'LIBXL_MAX_GRANT_DEFAULT'}),
@@ -715,7 +718,8 @@ libxl_device_disk = Struct("device_disk"
     ("colo_port", integer),
     ("colo_export", string),
     ("active_disk", string),
-    ("hidden_disk", string)
+    ("hidden_disk", string),
+    ("crypto_key_dir", string)
     ])
 
 libxl_device_nic = Struct("device_nic", [
--- a/tools/libxl/libxl_types_internal.idl
+++ b/tools/libxl/libxl_types_internal.idl
@@ -33,6 +33,7 @@ libxl__device_kind = Enumeration("device
     (15, "VSND"),
     (16, "VINPUT"),
     (17, "VWIF"),
+    (18, "VBD3"),
     ])
 
 libxl__console_backend = Enumeration("console_backend", [
--- a/tools/xl/xl_parse.c
+++ b/tools/xl/xl_parse.c
@@ -1590,6 +1590,7 @@ void parse_config_data(const char *confi
     if (!xlu_cfg_get_long(config, "max_event_channels", &l, 0))
         b_info->event_channels = l;
 
+    xlu_cfg_replace_string (config, "crypto_key_dir", &b_info->crypto_key_dir, 0);
     xlu_cfg_replace_string (config, "kernel", &b_info->kernel, 0);
     xlu_cfg_replace_string (config, "ramdisk", &b_info->ramdisk, 0);
     xlu_cfg_replace_string (config, "device_tree", &b_info->device_tree, 0);
@@ -2019,6 +2020,13 @@ void parse_config_data(const char *confi
             parse_disk_config(&config, buf2, disk);
 
             free(buf2);
+
+            if (d_config->b_info.crypto_key_dir) {
+                replace_string(&disk->crypto_key_dir,
+                               d_config->b_info.crypto_key_dir);
+            } else {
+                disk->crypto_key_dir = NULL;
+            }
         }
     }
 
--- a/tools/libxl/libxl_dm.c
+++ b/tools/libxl/libxl_dm.c
@@ -1889,7 +1889,9 @@ static int libxl__build_device_model_arg
                     continue;
                 }
 
-                assert(disks[i].backend != LIBXL_DISK_BACKEND_TAP);
+                if (disks[i].backend == LIBXL_DISK_BACKEND_TAP)
+                    target_path = libxl__blktap_devpath(gc, disks[i].pdev_path,
+                                                        disks[i].format, disks[i].crypto_key_dir);
                 target_path = libxl__device_disk_find_local_path(gc,
                                     guest_domid, &disks[i], true);
 
