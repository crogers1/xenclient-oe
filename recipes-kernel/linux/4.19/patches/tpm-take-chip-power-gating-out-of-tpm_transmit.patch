################################################################################
SHORT DESCRIPTION:
################################################################################
tpm: take TPM chip power gating out of tpm_transmit()

################################################################################
LONG DESCRIPTION:
################################################################################
Part of a patchqueue to fix the burstcount error on certain dell platforms

Backport of a3fbfae82b4cb from linux-stable

Call tpm_chip_start() and tpm_chip_stop() in
    
 * tpm_chip_register()
 * tpm_class_shutdown()
 * tpm_del_char_device()
 * tpm_pm_suspend() * tpm_try_get_ops() and tpm_put_ops()
 * tpm2_del_space()
    
And remove these calls from tpm_transmit(). The core reason for this
change is that in tpm_vtpm_proxy a locality change requires a virtual
TPM command (a command made up just for that driver).

The consequence of this is that this commit removes the remaining nested
calls.

################################################################################
CHANGELOG
################################################################################
Original author: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Modified by: Bryer Esengard <esengard@ainfosec.com>
Port to 4.19: Bryer Esengard <esengardb@ainfosec.com>

################################################################################
REMOVAL
################################################################################
Once we are on kernel 5.1+ this patch can be removed

################################################################################
UPSTREAM PLAN
################################################################################
None.

################################################################################
INTERNAL DEPENDENCIES
################################################################################
tpm-add-ptr-to-tpm_space-struct-to-file_priv.patch
tpm-add-support-for-nonblocking-operation.patch
tpm-add-support-for-partial-reads.patch
tpm-fix-invalid-contition-in-tpm_common_poll.patch
tpm-introduce-tpm_chip_start-and-tpm_chip_stop.patch

################################################################################
PATCHES
################################################################################

--- a/drivers/char/tpm/tpm-chip.c
+++ b/drivers/char/tpm/tpm-chip.c
@@ -167,10 +155,17 @@ int tpm_try_get_ops(struct tpm_chip *chip)
 
 	down_read(&chip->ops_sem);
 	if (!chip->ops)
+		goto out_ops;
+
+	mutex_lock(&chip->tpm_mutex);
+	rc = tpm_chip_start(chip, 0);
+	if (rc)
 		goto out_lock;
 
 	return 0;
 out_lock:
+	mutex_unlock(&chip->tpm_mutex);
+out_ops:
 	up_read(&chip->ops_sem);
 	put_device(&chip->dev);
 	return rc;
@@ -186,6 +181,8 @@ EXPORT_SYMBOL_GPL(tpm_try_get_ops);
  */
 void tpm_put_ops(struct tpm_chip *chip)
 {
+	tpm_chip_stop(chip, 0);
+	mutex_unlock(&chip->tpm_mutex);
 	up_read(&chip->ops_sem);
 	put_device(&chip->dev);
 }
@@ -300,7 +297,10 @@ static int tpm_class_shutdown(struct device *dev)
 
 	down_write(&chip->ops_sem);
 	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
-		tpm2_shutdown(chip, TPM2_SU_CLEAR);
+		if (!tpm_chip_start(chip, 0)) {
+			tpm2_shutdown(chip, TPM2_SU_CLEAR);
+			tpm_chip_stop(chip, 0);
+		}
 		chip->ops = NULL;
 	}
 	chip->ops = NULL;
@@ -479,8 +479,12 @@ static void tpm_del_char_device(struct tpm_chip *chip)
 
 	/* Make the driver uncallable. */
 	down_write(&chip->ops_sem);
-	if (chip->flags & TPM_CHIP_FLAG_TPM2)
-		tpm2_shutdown(chip, TPM2_SU_CLEAR);
+	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
+		if (!tpm_chip_start(chip, 0)) {
+			tpm2_shutdown(chip, TPM2_SU_CLEAR);
+			tpm_chip_stop(chip, 0);
+		}
+	}
 	chip->ops = NULL;
 	up_write(&chip->ops_sem);
 }
@@ -563,10 +567,14 @@ int tpm_chip_register(struct tpm_chip *chip)
 	int rc;
 
 	if (chip->ops->flags & TPM_OPS_AUTO_STARTUP) {
+		rc = tpm_chip_start(chip, 0);
+		if (rc)
+			return rc;
 		if (chip->flags & TPM_CHIP_FLAG_TPM2)
 			rc = tpm2_auto_startup(chip);
 		else
 			rc = tpm1_auto_startup(chip);
+		tpm_chip_stop(chip, 0);
 		if (rc)
 			return rc;
 	}
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -408,9 +408,6 @@ static ssize_t tpm_try_transmit(struct tpm_chip *chip,
 		return -E2BIG;
 	}
 
-	if (!(flags & TPM_TRANSMIT_UNLOCKED) && !(flags & TPM_TRANSMIT_NESTED))
-		mutex_lock(&chip->tpm_mutex);
-
 	if (chip->ops->clk_enable != NULL)
 		chip->ops->clk_enable(chip, true);
 
@@ -510,8 +507,6 @@ static ssize_t tpm_try_transmit(struct tpm_chip *chip,
 	if (chip->ops->clk_enable != NULL)
 		chip->ops->clk_enable(chip, false);
 
-	if (!(flags & TPM_TRANSMIT_UNLOCKED) && !(flags & TPM_TRANSMIT_NESTED))
-		mutex_unlock(&chip->tpm_mutex);
 	return rc ? rc : len;
 }
 
@@ -557,13 +552,9 @@ ssize_t tpm_transmit(struct tpm_chip *chip, struct tpm_space *space,
 	memcpy(save, buf, save_size);
 
 	for (;;) {
-		ret = tpm_chip_start(chip, flags);
-		if (ret)
-			return ret;
 
 		ret = tpm_try_transmit(chip, space, buf, bufsiz, flags);
 
-		tpm_chip_stop(chip, flags);
 		if (ret < 0)
 			break;
 		rc = be32_to_cpu(header->return_code);
@@ -1171,6 +1162,12 @@ int tpm_pm_suspend(struct device *dev)
 
 	if (chip->flags & TPM_CHIP_FLAG_TPM2) {
 		tpm2_shutdown(chip, TPM2_SU_STATE);
+		mutex_lock(&chip->tpm_mutex);
+		if (!tpm_chip_start(chip, 0)) {
+			tpm2_shutdown(chip, TPM2_SU_STATE);
+			tpm_chip_stop(chip, 0);
+		}
+		mutex_unlock(&chip->tpm_mutex);
 		return 0;
 	}
 
--- a/drivers/char/tpm/tpm2-space.c
+++ b/drivers/char/tpm/tpm2-space.c
@@ -61,7 +61,10 @@ int tpm2_init_space(struct tpm_space *space)
 void tpm2_del_space(struct tpm_chip *chip, struct tpm_space *space)
 {
 	mutex_lock(&chip->tpm_mutex);
-	tpm2_flush_sessions(chip, space);
+	if (!tpm_chip_start(chip, 0)) {
+		tpm2_flush_sessions(chip, space);
+		tpm_chip_stop(chip, 0);
+	}
 	mutex_unlock(&chip->tpm_mutex);
 	kfree(space->context_buf);
 	kfree(space->session_buf);
--- a/drivers/char/tpm/tpm_tis_core.c
+++ b/drivers/char/tpm/tpm_tis_core.c
@@ -917,7 +917,11 @@ int tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,
 	intmask &= ~TPM_GLOBAL_INT_ENABLE;
 	tpm_tis_write32(priv, TPM_INT_ENABLE(priv->locality), intmask);
 
+	rc = tpm_chip_start(chip, 0);
+	if (rc)
+		goto out_err;
 	rc = tpm2_probe(chip);
+	tpm_chip_stop(chip, 0);
 	if (rc)
 		goto out_err;
 
